---
title: "Heart Rate Monitors"
output: html_document
---

```{r setup, include=FALSE}
install.packages("RHRV", dependencies = TRUE)
library(rhdf5)
library(fitbitScraper)
library(lubridate)
library(plyr)
library(dplyr)
library(BlandAltmanLeh)
library(ggplot2)
library(RHRV)

```

##Fitbit data extraction
Extracting data from the fitbit cloud using the R package fitbitScraper. The other packages I am using in this is lubridate for the dates.

```{r}
cookie= login("penningtonjeff@yahoo.com","wearable10",rememberMe = TRUE)
startdate = as.Date("2016-11-23",format="%Y-%m-%d")
my.hrdata <- get_intraday_data(cookie,what="heart-rate",date =sprintf("%s",startdate))
newdata <- my.hrdata[144:152,-c(4,5,6)]
newdata
```

## Getting data from the Opensignals file

The opensignals generates an ECG file in the HD5 format. I am using the rhdf5 package to extract the ECG readings in mV.

```{r}
setwd("/Users/diwadkara/Desktop/Bitalino")
h5f = H5Fopen("./demo")
h5f
my.bitdata <- c(h5f$"20:15:10:26:64:88")
bitalino.df <- data.frame(my.bitdata$raw)
head(bitalino.df)
```

The text file for the Opensignals software
```{r}
my.data <- read.table("/Users/diwadkara/Desktop/Bitalino/demo1.txt")
names(my.data) <- c("nSeq", "I1", "I2", "I3", "I4", "A3")
str(my.data)
my.data <- transmute(my.data, ECG = (A3*3.3/2^15 - 3.3/2)/1100)
myecglist <- c(my.data$ECG)
write.csv(myecglist,file="ECGconverted.csv",row.names=FALSE)

```

##Signal processing code

```{r eval=TRUE}

#Transform the real and imaginary portions of the 
#FFT into magnitude and phase. The argument
#ff should be the output of the fft function
amplitude <- function( x ) { sqrt(Re(x)^2+Im(x)^2) }
phase     <- function( x ) { atan(Im(x)/Re(x)) }

#sinc function of frequency f
sinc      <- function( x, f ) { ifelse(x==0, 2*pi*f, sin(2*pi*f*x)/x) }

#Blackman window from 0..m
Blackman  <- function( m ) { 0.42-0.5*cos(2*pi*(0:m)/m)+0.08*cos(4*pi*(0:m)/m) }

#Hamming window from 0..m
Hamming   <- function( m ) { 0.54-0.46*cos(2*pi*(0:m)/m) }

#simple low pass filter
#y - vector to filter
#t - time interval between measurements (s)
#f - low pass frequency (Hz)
lpf <- function( y, t, f ) {
  rc <- 1 / ( 2 * pi * f )
  a  <- t / ( t + rc )
  n  <- length( y )
  yf <- y
  for( i in 2:length(y) ) {
    yf[i] <- a * y[i] + (1-a) * yf[i-1]
  }
  return( yf )
}  

#windowed sinc low pass filter
#y - vector to filter
#t - time interval between measurements (s)
#f - low pass frequency (Hz)
wlpf <- function( y, t, f ) {
  m  <- min(floor(length(y)/2), 500)
  #generate the sinc kernel
  rk <- sinc(-m:m, f*t)  
  #apply the Blackman window
  bk <- Blackman(2*m) * rk
  #pad the filter with zeros
  k  <- c(bk, rep(0,length(y)-length(bk)))
  #convolve y with the filter kernel
  fy  <- fft(fft(k)*fft(y), inverse=TRUE)
  return(Re(fy))
}

dat  <- scan(file="ECGconverted.csv")
dat  <- ( dat - mean(dat) ) / sd(dat)

#filter high frequency noise
fdat <- wlpf(dat, 1/100, 30)
fdat <- (fdat-mean(fdat))/sd(fdat)

#isolate respiration bias
rdat <- wlpf(dat, 1/1000, 1)
rdat <- (rdat-mean(rdat))/sd(rdat)

#subtract respiration bias from ecg signal
edat <- fdat - rdat

require(lattice)
xplot <- rep((0:(length(dat)-1))/1000,4)
yplot <- c(dat, fdat, rdat, edat)
gplot <- c(rep("Raw",length(dat)),
           rep("High Frequency Filter",length(dat)),
           rep("Low Frequency Filter",length(dat)),
           rep("ECG",length(dat)))
tp <- xyplot(yplot~xplot|gplot,type="l",layout=c(1,4), xlab="Time", ylab="V")

#uncomment the following to save an image
trellis.device(png, file="ecgfilter.png", height=750, width=750)
print(tp)
dev.off()

```


#Visualization of the data in plots

```{r}
plot()

```

##Statistical Analysis

#BlandAltmanPlots
```{r eval=TRUE}
Bitalino <- c(myecglist[1:9])
FitBit <- c(newdata$bpm)
bland.altman.plot(Bitalino, FitBit)

```

##Corelation
```{r}

```

